<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LAB Golf 자동주문 시스템</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #fff;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    header h1 {
      font-size: 2rem;
      margin-bottom: 10px;
      background: linear-gradient(90deg, #00d4ff, #7b2cbf);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    header p {
      color: #8892b0;
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }

    .card h2 {
      font-size: 1.2rem;
      margin-bottom: 16px;
      color: #00d4ff;
    }

    textarea {
      width: 100%;
      height: 250px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 16px;
      color: #fff;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 14px;
      resize: vertical;
    }

    textarea:focus {
      outline: none;
      border-color: #00d4ff;
    }

    textarea::placeholder {
      color: #666;
    }

    .button-group {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-primary {
      background: linear-gradient(90deg, #00d4ff, #7b2cbf);
      color: #fff;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(0, 212, 255, 0.4);
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .status-bar {
      display: none;
      margin-top: 20px;
    }

    .status-bar.active {
      display: block;
    }

    .progress-container {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      height: 8px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #00d4ff, #7b2cbf);
      width: 0%;
      transition: width 0.3s ease;
    }

    .status-text {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .status-message {
      color: #8892b0;
    }

    .status-step {
      font-size: 12px;
      color: #666;
    }

    .parsed-options {
      display: none;
    }

    .parsed-options.active {
      display: block;
    }

    .options-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 12px;
    }

    .option-item {
      background: rgba(0, 0, 0, 0.2);
      padding: 12px;
      border-radius: 8px;
      border-left: 3px solid #00d4ff;
    }

    .option-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 4px;
    }

    .option-value {
      font-weight: 600;
      color: #fff;
    }

    .option-value.missing {
      color: #ff6b6b;
    }

    .results {
      display: none;
      margin-top: 20px;
    }

    .results.active {
      display: block;
    }

    .result-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      margin-bottom: 4px;
    }

    .result-item.success {
      border-left: 3px solid #00ff88;
    }

    .result-item.failed {
      border-left: 3px solid #ff6b6b;
    }

    .result-status {
      font-weight: 600;
    }

    .result-status.success {
      color: #00ff88;
    }

    .result-status.failed {
      color: #ff6b6b;
    }

    .alert {
      padding: 12px 16px;
      border-radius: 8px;
      margin-top: 16px;
    }

    .alert-success {
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid #00ff88;
      color: #00ff88;
    }

    .alert-error {
      background: rgba(255, 107, 107, 0.1);
      border: 1px solid #ff6b6b;
      color: #ff6b6b;
    }

    .example-text {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
    }

    /* 브라우저 상태 섹션 */
    .browser-status {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 20px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #666;
    }

    .status-dot.connected {
      background: #00d4ff;
      box-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
    }

    .status-dot.logged-in {
      background: #00ff88;
      box-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
    }

    .status-dot.disconnected {
      background: #ff6b6b;
    }

    .browser-buttons {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }

    .btn-browser {
      padding: 10px 20px;
      font-size: 13px;
    }

    .btn-open {
      background: linear-gradient(90deg, #00d4ff, #0099cc);
    }

    .btn-close {
      background: rgba(255, 107, 107, 0.2);
      border: 1px solid #ff6b6b;
      color: #ff6b6b;
    }

    .btn-close:hover {
      background: rgba(255, 107, 107, 0.3);
    }

    .btn-refresh {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #8892b0;
      padding: 10px 16px;
    }

    .btn-refresh:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .login-hint {
      font-size: 12px;
      color: #8892b0;
      margin-top: 12px;
      padding: 8px 12px;
      background: rgba(0, 212, 255, 0.1);
      border-radius: 8px;
      border-left: 3px solid #00d4ff;
    }

    /* 탭 네비게이션 */
    .tab-nav {
      display: flex;
      gap: 4px;
      margin-bottom: 20px;
    }

    .tab-btn {
      padding: 10px 24px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      color: #8892b0;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
    }

    .tab-btn.active {
      background: rgba(255, 255, 255, 0.1);
      color: #00d4ff;
      border-color: rgba(0, 212, 255, 0.3);
    }

    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* CSV 업로드 영역 */
    .csv-upload-area {
      border: 2px dashed rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 32px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }

    .csv-upload-area:hover,
    .csv-upload-area.dragover {
      border-color: #00d4ff;
      background: rgba(0, 212, 255, 0.05);
    }

    .csv-upload-area input[type="file"] { display: none; }

    .csv-upload-area .upload-icon {
      font-size: 36px;
      margin-bottom: 8px;
      opacity: 0.6;
    }

    .csv-upload-area .upload-text {
      color: #8892b0;
      font-size: 14px;
    }

    .csv-upload-area .file-name {
      color: #00d4ff;
      font-weight: 600;
      margin-top: 8px;
    }

    /* CSV 미리보기 테이블 */
    .csv-table-wrap {
      overflow-x: auto;
      margin-top: 16px;
    }

    .csv-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .csv-table th {
      background: rgba(0, 212, 255, 0.15);
      color: #00d4ff;
      padding: 8px 10px;
      text-align: left;
      white-space: nowrap;
      position: sticky;
      top: 0;
    }

    .csv-table td {
      padding: 6px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      white-space: nowrap;
    }

    .csv-table tr:hover td {
      background: rgba(255, 255, 255, 0.03);
    }

    .csv-table tr.invalid td {
      color: #ff6b6b;
      opacity: 0.7;
    }

    .csv-table tr.execution-failed td {
      background: rgba(255, 107, 107, 0.12);
      border-bottom-color: rgba(255, 107, 107, 0.2);
    }

    .csv-table .row-status {
      text-align: center;
      font-weight: 600;
    }

    .csv-table .row-status.ok { color: #00ff88; }
    .csv-table .row-status.fail { color: #ff6b6b; text-decoration: underline dotted; }
    .csv-table .row-status.running { color: #00d4ff; }
    .csv-table .row-status.pending { color: #666; }

    .csv-summary {
      display: flex;
      gap: 16px;
      margin: 12px 0;
      font-size: 14px;
    }

    .csv-summary span {
      padding: 4px 12px;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.2);
    }

    /* 배치 진행 바 */
    .batch-progress {
      display: none;
      margin-top: 16px;
    }

    .batch-progress.active { display: block; }

    .batch-progress-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 13px;
      color: #8892b0;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>LAB Golf 자동주문 시스템</h1>
      <p>주문 정보를 입력하고 자동으로 장바구니에 담기</p>
    </header>

    <!-- 브라우저 상태 카드 -->
    <div class="card">
      <h2>1. 브라우저 연결</h2>
      <div class="browser-status">
        <div class="status-indicator">
          <span class="status-dot" id="connectionDot"></span>
          <span id="connectionText">연결 안됨</span>
        </div>
        <div class="status-indicator">
          <span class="status-dot" id="loginDot"></span>
          <span id="loginText">로그인 필요</span>
        </div>
      </div>
      <div class="browser-buttons">
        <button class="btn-primary btn-browser btn-open" id="openBrowserBtn">브라우저 열기</button>
        <button class="btn-secondary btn-browser btn-close" id="closeBrowserBtn" disabled>브라우저 닫기</button>
        <button class="btn-secondary btn-browser btn-refresh" id="refreshStatusBtn">상태 새로고침</button>
      </div>
      <div class="login-hint" id="loginHint" style="display: none;">
        브라우저에서 LabGolf 사이트에 로그인해주세요. 로그인 완료 후 "상태 새로고침"을 클릭하세요.
      </div>
    </div>

    <!-- 탭 네비게이션 -->
    <div class="tab-nav">
      <button class="tab-btn active" data-tab="single">단건 주문</button>
      <button class="tab-btn" data-tab="batch">CSV 일괄 주문</button>
    </div>

    <!-- 단건 주문 탭 -->
    <div class="tab-content active" id="tab-single">
      <div class="card">
        <h2>2. 주문 정보 입력</h2>
        <textarea id="orderInput" placeholder="주문 정보를 붙여넣으세요...

예시:
OZ.1i - CUSTOM
Hand: Right
Putting style: Standard
Head weight: Standard
Shaft: GEARS x L.A.B. (Black)
Shaft length: 34
Shaft lean: 0º
Lie angle: 69°
Putter color: Black
Alignment Front: E
Alignment Back: 2
Grip selection: SuperStroke Flatso 2.0"></textarea>

        <div class="button-group">
          <button class="btn-primary" id="parseBtn">파싱 미리보기</button>
          <button class="btn-primary" id="orderBtn" disabled>자동주문 실행</button>
          <button class="btn-secondary" id="clearBtn">초기화</button>
        </div>

        <div class="status-bar" id="statusBar">
          <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
          </div>
          <div class="status-text">
            <span class="status-message" id="statusMessage">대기 중...</span>
            <span class="status-step" id="statusStep"></span>
          </div>
        </div>
      </div>

      <div class="card parsed-options" id="parsedOptions">
        <h2>파싱된 옵션</h2>
        <div class="options-grid" id="optionsGrid"></div>
        <div id="validationMessage"></div>
      </div>

      <div class="card results" id="resultsCard">
        <h2>실행 결과</h2>
        <div id="resultsList"></div>
      </div>
    </div>

    <!-- CSV 일괄 주문 탭 -->
    <div class="tab-content" id="tab-batch">
      <div class="card">
        <h2>2. CSV 파일 업로드</h2>
        <div class="csv-upload-area" id="csvUploadArea">
          <input type="file" id="csvFileInput" accept=".csv">
          <div class="upload-icon">CSV</div>
          <div class="upload-text">CSV 파일을 드래그하거나 클릭하여 업로드</div>
          <div class="file-name" id="csvFileName"></div>
        </div>

        <div class="button-group">
          <button class="btn-primary" id="csvParseBtn" disabled>파싱 미리보기</button>
          <button class="btn-primary" id="csvBatchBtn" disabled>일괄주문 실행</button>
          <button class="btn-secondary" id="csvStopBtn" style="display:none; background:rgba(255,107,107,0.2); border-color:#ff6b6b; color:#ff6b6b;">배치 중지</button>
          <button class="btn-secondary" id="csvClearBtn">초기화</button>
        </div>
        <div id="singleOrderArea" style="display:none; margin-top:12px;">
          <div style="display:flex; gap:8px; align-items:center;">
            <input type="text" id="orderIdInput" placeholder="주문번호 입력 후 단건 실행..."
                   style="flex:1; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:8px; padding:10px 16px; color:#fff; font-size:13px;">
            <button class="btn-primary" id="csvSingleBtn" style="white-space:nowrap; padding:10px 20px;">단건 실행</button>
          </div>
        </div>
      </div>

      <div class="card" id="csvPreviewCard" style="display:none;">
        <h2>CSV 미리보기</h2>
        <div class="csv-summary" id="csvSummary"></div>
        <div class="csv-table-wrap">
          <table class="csv-table" id="csvTable">
            <thead id="csvTableHead"></thead>
            <tbody id="csvTableBody"></tbody>
          </table>
        </div>
      </div>

      <div class="card" id="batchProgressCard" style="display:none;">
        <h2>배치 진행 상황</h2>
        <div class="batch-progress active">
          <div class="batch-progress-label">
            <span id="batchLabel">준비 중...</span>
            <span id="batchCount">0/0</span>
          </div>
          <div class="progress-container">
            <div class="progress-bar" id="batchProgressBar"></div>
          </div>
          <div class="status-text">
            <span class="status-message" id="batchStatusMessage">대기 중...</span>
            <span class="status-step" id="batchStatusStep"></span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const orderInput = document.getElementById('orderInput');
    const parseBtn = document.getElementById('parseBtn');
    const orderBtn = document.getElementById('orderBtn');
    const clearBtn = document.getElementById('clearBtn');
    const statusBar = document.getElementById('statusBar');
    const progressBar = document.getElementById('progressBar');
    const statusMessage = document.getElementById('statusMessage');
    const statusStep = document.getElementById('statusStep');
    const parsedOptions = document.getElementById('parsedOptions');
    const optionsGrid = document.getElementById('optionsGrid');
    const validationMessage = document.getElementById('validationMessage');
    const resultsCard = document.getElementById('resultsCard');
    const resultsList = document.getElementById('resultsList');

    // 브라우저 컨트롤 요소
    const openBrowserBtn = document.getElementById('openBrowserBtn');
    const closeBrowserBtn = document.getElementById('closeBrowserBtn');
    const refreshStatusBtn = document.getElementById('refreshStatusBtn');
    const connectionDot = document.getElementById('connectionDot');
    const connectionText = document.getElementById('connectionText');
    const loginDot = document.getElementById('loginDot');
    const loginText = document.getElementById('loginText');
    const loginHint = document.getElementById('loginHint');

    let eventSource = null;
    let browserConnected = false;
    let browserLoggedIn = false;

    // ===== 브라우저 상태 관리 =====

    // 브라우저 상태 업데이트
    async function updateBrowserStatus() {
      try {
        const response = await fetch('/api/browser/status');
        const data = await response.json();

        browserConnected = data.connected;
        browserLoggedIn = data.loggedIn;

        // 연결 상태 표시
        if (browserConnected) {
          connectionDot.className = 'status-dot connected';
          connectionText.textContent = '연결됨';
          closeBrowserBtn.disabled = false;
          openBrowserBtn.textContent = '브라우저 열기';
        } else {
          connectionDot.className = 'status-dot disconnected';
          connectionText.textContent = '연결 안됨';
          closeBrowserBtn.disabled = true;
        }

        // 로그인 상태 표시
        if (browserLoggedIn) {
          loginDot.className = 'status-dot logged-in';
          loginText.textContent = '로그인됨';
          loginHint.style.display = 'none';
        } else if (browserConnected) {
          loginDot.className = 'status-dot disconnected';
          loginText.textContent = '로그인 필요';
          loginHint.style.display = 'block';
        } else {
          loginDot.className = 'status-dot';
          loginText.textContent = '로그인 필요';
          loginHint.style.display = 'none';
        }

        // 자동주문 버튼 활성화 조건 업데이트
        updateOrderButtonState();

      } catch (error) {
        console.error('브라우저 상태 확인 오류:', error);
      }
    }

    // 자동주문 버튼 상태 업데이트
    function updateOrderButtonState() {
      const hasValidOptions = parsedOptions.classList.contains('active') &&
                              validationMessage.querySelector('.alert-success');
      orderBtn.disabled = !(browserConnected && hasValidOptions);
    }

    // 브라우저 열기
    openBrowserBtn.addEventListener('click', async () => {
      openBrowserBtn.disabled = true;
      openBrowserBtn.textContent = '열기 중...';

      try {
        const response = await fetch('/api/browser/open', { method: 'POST' });
        const data = await response.json();

        if (data.success) {
          setTimeout(updateBrowserStatus, 1000);
        } else {
          alert('브라우저 열기 실패: ' + data.error);
        }
      } catch (error) {
        alert('오류: ' + error.message);
      } finally {
        openBrowserBtn.disabled = false;
        openBrowserBtn.textContent = '브라우저 열기';
      }
    });

    // 브라우저 닫기
    closeBrowserBtn.addEventListener('click', async () => {
      closeBrowserBtn.disabled = true;

      try {
        const response = await fetch('/api/browser/close', { method: 'POST' });
        const data = await response.json();

        if (data.success) {
          await updateBrowserStatus();
        } else {
          alert('브라우저 닫기 실패: ' + data.error);
        }
      } catch (error) {
        alert('오류: ' + error.message);
      } finally {
        closeBrowserBtn.disabled = !browserConnected;
      }
    });

    // 상태 새로고침
    refreshStatusBtn.addEventListener('click', async () => {
      refreshStatusBtn.disabled = true;
      refreshStatusBtn.textContent = '확인 중...';

      await updateBrowserStatus();

      refreshStatusBtn.disabled = false;
      refreshStatusBtn.textContent = '상태 새로고침';
    });

    // 초기 상태 확인
    updateBrowserStatus();

    // 파싱 미리보기
    parseBtn.addEventListener('click', async () => {
      const orderText = orderInput.value.trim();
      if (!orderText) {
        alert('주문 정보를 입력해주세요.');
        return;
      }

      try {
        const response = await fetch('/api/parse', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ orderText })
        });

        const data = await response.json();

        if (data.success) {
          displayParsedOptions(data.options, data.validation);
          // v2: 브라우저 연결 + 로그인 + 유효한 옵션 모두 필요
          updateOrderButtonState();
        } else {
          alert('파싱 오류: ' + data.error);
        }
      } catch (error) {
        alert('오류 발생: ' + error.message);
      }
    });

    // 옵션 표시
    function displayParsedOptions(options, validation) {
      const optionLabels = {
        product: '제품',
        hand: 'Hand',
        puttingStyle: 'Putting Style',
        headWeight: 'Head Weight',
        shaft: 'Shaft',
        shaftLength: 'Shaft Length',
        shaftLean: 'Shaft Lean',
        lieAngle: 'Lie Angle',
        putterColor: 'Putter Color',
        alignmentFront: 'Alignment Front',
        alignmentBack: 'Alignment Back',
        gripSelection: 'Grip Selection',
        riser: 'Riser',
        insert: 'Insert',
        headcover: 'Headcover',
        buildTime: 'Build Time'
      };

      let html = '';
      for (const [key, label] of Object.entries(optionLabels)) {
        const value = options[key];
        const isMissing = validation.missing.includes(key);
        html += `
          <div class="option-item">
            <div class="option-label">${label}</div>
            <div class="option-value ${isMissing ? 'missing' : ''}">${value || '(미입력)'}</div>
          </div>
        `;
      }
      optionsGrid.innerHTML = html;

      if (!validation.valid) {
        validationMessage.innerHTML = `
          <div class="alert alert-error">
            필수 옵션 누락: ${validation.missing.join(', ')}
          </div>
        `;
      } else {
        validationMessage.innerHTML = `
          <div class="alert alert-success">
            모든 필수 옵션이 입력되었습니다. 자동주문을 실행할 수 있습니다.
          </div>
        `;
      }

      parsedOptions.classList.add('active');
    }

    // 자동주문 실행
    orderBtn.addEventListener('click', async () => {
      const orderText = orderInput.value.trim();
      if (!orderText) {
        alert('주문 정보를 입력해주세요.');
        return;
      }

      // 상태 표시
      statusBar.classList.add('active');
      resultsCard.classList.remove('active');
      orderBtn.disabled = true;
      parseBtn.disabled = true;

      // SSE 연결
      if (eventSource) {
        eventSource.close();
      }
      eventSource = new EventSource('/api/status/stream');

      eventSource.onmessage = (event) => {
        const status = JSON.parse(event.data);
        updateStatusDisplay(status);

        if (status.status === 'completed' || status.status === 'error') {
          eventSource.close();
          parseBtn.disabled = false;
          updateOrderButtonState();
        }
      };

      // 주문 실행 요청
      try {
        const response = await fetch('/api/order', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ orderText })
        });

        const data = await response.json();
        if (!data.success && data.error) {
          alert('오류: ' + data.error);
          statusBar.classList.remove('active');
          parseBtn.disabled = false;
          // 브라우저 상태 재확인 후 버튼 상태 업데이트
          await updateBrowserStatus();
        }
      } catch (error) {
        alert('오류 발생: ' + error.message);
        statusBar.classList.remove('active');
        parseBtn.disabled = false;
        await updateBrowserStatus();
      }
    });

    // 상태 업데이트
    function updateStatusDisplay(status) {
      progressBar.style.width = status.progress + '%';
      statusMessage.textContent = status.message;
      statusStep.textContent = status.step;

      if (status.status === 'completed') {
        statusMessage.style.color = '#00ff88';
      } else if (status.status === 'error') {
        statusMessage.style.color = '#ff6b6b';
      } else {
        statusMessage.style.color = '#8892b0';
      }
    }

    // 초기화
    clearBtn.addEventListener('click', () => {
      orderInput.value = '';
      parsedOptions.classList.remove('active');
      statusBar.classList.remove('active');
      resultsCard.classList.remove('active');
      progressBar.style.width = '0%';
      updateOrderButtonState();
    });

    // 텍스트 입력 시 버튼 비활성화 (다시 파싱 필요)
    orderInput.addEventListener('input', () => {
      if (parsedOptions.classList.contains('active')) {
        parsedOptions.classList.remove('active');
      }
      updateOrderButtonState();
    });

    // 주기적으로 브라우저 상태 확인 (10초마다)
    setInterval(updateBrowserStatus, 10000);

    // ===== 탭 전환 =====
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
        saveState();
      });
    });

    // ===== CSV 일괄 주문 =====
    const csvFileInput = document.getElementById('csvFileInput');
    const csvUploadArea = document.getElementById('csvUploadArea');
    const csvFileName = document.getElementById('csvFileName');
    const csvParseBtn = document.getElementById('csvParseBtn');
    const csvBatchBtn = document.getElementById('csvBatchBtn');
    const csvStopBtn = document.getElementById('csvStopBtn');
    const csvClearBtn = document.getElementById('csvClearBtn');
    const csvPreviewCard = document.getElementById('csvPreviewCard');
    const csvSummary = document.getElementById('csvSummary');
    const csvTableHead = document.getElementById('csvTableHead');
    const csvTableBody = document.getElementById('csvTableBody');
    const batchProgressCard = document.getElementById('batchProgressCard');
    const batchProgressBar = document.getElementById('batchProgressBar');
    const batchLabel = document.getElementById('batchLabel');
    const batchCount = document.getElementById('batchCount');
    const batchStatusMessage = document.getElementById('batchStatusMessage');
    const batchStatusStep = document.getElementById('batchStatusStep');

    const singleOrderArea = document.getElementById('singleOrderArea');
    const orderIdInput = document.getElementById('orderIdInput');
    const csvSingleBtn = document.getElementById('csvSingleBtn');

    let csvBase64 = null;
    let csvOrders = null; // 파싱된 주문 목록
    let batchRunning = false; // 배치 실행 상태 (UI 측)
    let currentBatchState = 'idle'; // 'idle' | 'running' | 'stopped' | 'done'

    // ===== 상태 유지 (localStorage) =====
    const STORAGE_KEY = 'labgolf_batch_state';

    function saveState() {
      console.log('[State] saveState 호출됨, csvOrders:', csvOrders ? csvOrders.length + '건' : 'null');
      const state = {
        activeTab: document.querySelector('.tab-btn.active')?.dataset.tab || 'single',
        csvFileName: csvFileName.textContent || '',
        csvOrders: csvOrders,
        csvPreviewData: csvOrders ? {
          total: csvOrders.length,
          valid: csvOrders.filter(o => o.valid).length,
          invalid: csvOrders.filter(o => !o.valid).length,
        } : null,
        csvPreviewVisible: csvPreviewCard.style.display !== 'none',
        batchProgressVisible: batchProgressCard.style.display !== 'none',
        batchProgress: {
          label: batchLabel.textContent,
          count: batchCount.textContent,
          message: batchStatusMessage.textContent,
          messageColor: batchStatusMessage.style.color,
          progressWidth: batchProgressBar.style.width,
        },
        batchUIState: currentBatchState,
        rowStatuses: {},
      };

      if (csvOrders) {
        csvOrders.forEach((o, i) => {
          const statusEl = document.getElementById('csv-status-' + i);
          const rowEl = document.getElementById('csv-row-' + i);
          if (statusEl) {
            state.rowStatuses[i] = {
              text: statusEl.textContent,
              className: statusEl.className,
              title: statusEl.title || '',
              rowFailed: rowEl ? rowEl.classList.contains('execution-failed') : false,
            };
          }
        });
      }

      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        console.log('[State] 저장 완료, 크기:', JSON.stringify(state).length, 'bytes');
      } catch (e) {
        console.warn('[State] 저장 실패:', e);
      }
    }

    function clearSavedState() {
      localStorage.removeItem(STORAGE_KEY);
    }

    function loadState() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        console.log('[State] loadState 호출됨, 저장된 데이터:', saved ? saved.length + ' bytes' : 'null');
        if (!saved) return;
        const state = JSON.parse(saved);
        console.log('[State] 복원할 상태:', { activeTab: state.activeTab, csvOrders: state.csvOrders?.length, batchUIState: state.batchUIState, csvPreviewVisible: state.csvPreviewVisible });

        // 1. 탭 복원
        if (state.activeTab) {
          document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          const tabBtn = document.querySelector(`.tab-btn[data-tab="${state.activeTab}"]`);
          if (tabBtn) tabBtn.classList.add('active');
          const tabContent = document.getElementById('tab-' + state.activeTab);
          if (tabContent) tabContent.classList.add('active');
        }

        // 2. CSV 주문 데이터 + 미리보기 복원
        if (state.csvOrders && state.csvOrders.length > 0) {
          csvOrders = state.csvOrders;
          csvFileName.textContent = state.csvFileName || '';
          singleOrderArea.style.display = 'block';

          if (state.csvPreviewVisible && state.csvPreviewData) {
            displayCsvPreview({
              orders: csvOrders,
              ...state.csvPreviewData,
            });

            // 3. 행 상태 복원 (displayCsvPreview가 초기화하므로 그 뒤에)
            if (state.rowStatuses) {
              Object.entries(state.rowStatuses).forEach(([idx, status]) => {
                const statusEl = document.getElementById('csv-status-' + idx);
                const rowEl = document.getElementById('csv-row-' + idx);
                if (statusEl) {
                  statusEl.textContent = status.text;
                  statusEl.className = status.className;
                  if (status.title) {
                    statusEl.title = status.title;
                    statusEl.style.cursor = 'help';
                  }
                }
                if (rowEl && status.rowFailed) {
                  rowEl.classList.add('execution-failed');
                }
              });
            }
          }

          // 4. 배치 진행 상황 복원
          if (state.batchProgressVisible) {
            batchProgressCard.style.display = 'block';
            batchLabel.textContent = state.batchProgress.label || '';
            batchCount.textContent = state.batchProgress.count || '0/0';
            batchStatusMessage.textContent = state.batchProgress.message || '';
            batchStatusMessage.style.color = state.batchProgress.messageColor || '#8892b0';
            batchProgressBar.style.width = state.batchProgress.progressWidth || '0%';
          }

          // 5. 배치 UI 상태 복원
          if (state.batchUIState === 'running') {
            // 실행 중이었으면 서버 상태 확인 후 재연결
            checkAndReconnectBatch();
          } else if (state.batchUIState === 'stopped') {
            setBatchUIState('stopped');
          } else if (state.batchUIState === 'done') {
            setBatchUIState('done');
          }

          // csvBase64 없으므로 파싱 버튼 비활성화
          csvParseBtn.disabled = true;
        }
      } catch (e) {
        console.warn('[State] 복원 실패:', e);
      }
    }

    // 배치 실행 중이었다면 서버 상태 확인 후 SSE 재연결
    async function checkAndReconnectBatch() {
      try {
        const response = await fetch('/api/batch/status');
        const status = await response.json();

        if (status.isBatchRunning) {
          setBatchUIState('running');
          connectBatchSSE();
        } else if (status.canResume) {
          setBatchUIState('stopped');
        } else {
          setBatchUIState('done');
        }
      } catch (e) {
        console.warn('[State] 배치 상태 확인 실패:', e);
        setBatchUIState('done');
      }
    }

    // 파일 업로드 클릭
    csvUploadArea.addEventListener('click', () => csvFileInput.click());

    // 드래그 앤 드롭
    csvUploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      csvUploadArea.classList.add('dragover');
    });
    csvUploadArea.addEventListener('dragleave', () => {
      csvUploadArea.classList.remove('dragover');
    });
    csvUploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      csvUploadArea.classList.remove('dragover');
      if (e.dataTransfer.files.length > 0) {
        handleCsvFile(e.dataTransfer.files[0]);
      }
    });

    csvFileInput.addEventListener('change', () => {
      if (csvFileInput.files.length > 0) {
        handleCsvFile(csvFileInput.files[0]);
      }
    });

    function handleCsvFile(file) {
      if (!file.name.endsWith('.csv')) {
        alert('CSV 파일만 업로드 가능합니다.');
        return;
      }
      csvFileName.textContent = file.name;
      const reader = new FileReader();
      reader.onload = () => {
        const arrayBuffer = reader.result;
        const bytes = new Uint8Array(arrayBuffer);
        let binary = '';
        for (let i = 0; i < bytes.length; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        csvBase64 = btoa(binary);
        csvParseBtn.disabled = false;
        csvBatchBtn.disabled = true;
        csvPreviewCard.style.display = 'none';
      };
      reader.readAsArrayBuffer(file);
    }

    // CSV 파싱 미리보기
    csvParseBtn.addEventListener('click', async () => {
      if (!csvBase64) return;
      csvParseBtn.disabled = true;
      csvParseBtn.textContent = '파싱 중...';

      try {
        const response = await fetch('/api/csv/parse', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ csvData: csvBase64 })
        });
        const data = await response.json();

        if (!data.success) {
          alert('CSV 파싱 오류: ' + data.error);
          return;
        }

        csvOrders = data.orders;
        displayCsvPreview(data);
        csvBatchBtn.disabled = !(browserConnected && data.valid > 0);
      } catch (error) {
        alert('오류: ' + error.message);
      } finally {
        csvParseBtn.disabled = false;
        csvParseBtn.textContent = '파싱 미리보기';
      }
    });

    function displayCsvPreview(data) {
      csvSummary.innerHTML = `
        <span>전체: ${data.total}건</span>
        <span style="color:#00ff88;">유효: ${data.valid}건</span>
        ${data.invalid > 0 ? `<span style="color:#ff6b6b;">오류: ${data.invalid}건</span>` : ''}
      `;

      csvTableHead.innerHTML = `<tr>
        <th>#</th><th>상태</th><th>주문번호</th><th>제품</th><th>수량</th><th>Hand</th>
        <th>Style</th><th>Weight</th><th>Shaft</th><th>Length</th><th>Lean</th>
        <th>Lie</th><th>Color</th><th>Riser</th>
        <th>Grip</th><th>Alignment</th>
      </tr>`;

      csvTableBody.innerHTML = data.orders.map((o, i) => {
        const opt = o.options;
        const align = opt.alignmentMark || ((opt.alignmentFront || '') + (opt.alignmentBack && opt.alignmentBack !== '-' ? '/' + opt.alignmentBack : ''));
        return `<tr class="${o.valid ? '' : 'invalid'}" id="csv-row-${i}">
          <td>${o.index}</td>
          <td class="row-status ${o.valid ? 'pending' : 'fail'}" id="csv-status-${i}">${o.valid ? '-' : 'ERR'}</td>
          <td>${o.orderId}</td>
          <td>${opt.product}</td>
          <td>${o.quantity > 1 ? `<strong style="color:#00ff88;">${o.quantity}</strong>` : o.quantity}</td>
          <td>${opt.hand || '-'}</td>
          <td>${opt.puttingStyle || '-'}</td>
          <td>${opt.headWeight || '-'}</td>
          <td>${opt.shaft || '-'}</td>
          <td>${opt.shaftLength || '-'}</td>
          <td>${opt.shaftLean || '-'}</td>
          <td>${opt.lieAngle || '-'}</td>
          <td>${opt.putterColor || '-'}</td>
          <td>${opt.riser || '-'}</td>
          <td>${opt.gripSelection || '-'}</td>
          <td>${align || '-'}</td>
        </tr>`;
      }).join('');

      csvPreviewCard.style.display = 'block';
      singleOrderArea.style.display = 'block';
      saveState();
    }

    // 배치 UI 상태 전환
    let stopBtnMode = 'stop'; // 'stop' | 'resume'

    function setBatchUIState(state) {
      // state: 'idle' | 'running' | 'stopped' | 'done'
      batchRunning = (state === 'running');
      currentBatchState = state;

      if (state === 'running') {
        csvBatchBtn.disabled = true;
        csvParseBtn.disabled = true;
        csvSingleBtn.disabled = true;
        csvStopBtn.style.display = '';
        csvStopBtn.disabled = false;
        csvStopBtn.textContent = '배치 중지';
        csvStopBtn.style.background = 'rgba(255,107,107,0.2)';
        csvStopBtn.style.borderColor = '#ff6b6b';
        csvStopBtn.style.color = '#ff6b6b';
        stopBtnMode = 'stop';
        csvClearBtn.disabled = true;
      } else if (state === 'stopped') {
        csvBatchBtn.disabled = true;
        csvParseBtn.disabled = false;
        csvSingleBtn.disabled = false;
        csvStopBtn.style.display = '';
        csvStopBtn.disabled = false;
        csvStopBtn.textContent = '이어하기';
        csvStopBtn.style.background = 'rgba(0,255,136,0.2)';
        csvStopBtn.style.borderColor = '#00ff88';
        csvStopBtn.style.color = '#00ff88';
        stopBtnMode = 'resume';
        csvClearBtn.disabled = false;
      } else if (state === 'done') {
        csvBatchBtn.disabled = false;
        csvParseBtn.disabled = false;
        csvSingleBtn.disabled = false;
        csvStopBtn.style.display = 'none';
        stopBtnMode = 'stop';
        csvClearBtn.disabled = false;
      } else {
        // idle
        csvSingleBtn.disabled = false;
        csvStopBtn.style.display = 'none';
        stopBtnMode = 'stop';
        csvClearBtn.disabled = false;
      }
      saveState();
    }

    // SSE 배치 핸들러 (공통)
    // ordersForExecution: 실행할 주문 목록 (단건 실행 시 [order] 전달, 미전달 시 전체 유효 주문 사용)
    function connectBatchSSE(ordersForExecution) {
      if (eventSource) eventSource.close();
      eventSource = new EventSource('/api/status/stream');

      const validOrders = ordersForExecution || (csvOrders ? csvOrders.filter(o => o.valid) : []);
      let currentBatchIdx = -1;

      eventSource.onmessage = (event) => {
        const status = JSON.parse(event.data);
        batchStatusMessage.textContent = status.message;
        batchStatusStep.textContent = status.step;

        if (status.batchProgress) {
          const bp = status.batchProgress;
          batchCount.textContent = `${bp.current}/${bp.total}`;
          batchProgressBar.style.width = status.progress + '%';

          // 누적 결과가 있으면 항상 반영
          if (bp.results && bp.results.length > 0) {
            bp.results.forEach((r, i) => updateCsvRowStatus(i, r, validOrders));
          }

          // 현재 주문 RUN 표시
          const batchIdx = bp.current - 1;
          if (batchIdx !== currentBatchIdx) {
            currentBatchIdx = batchIdx;
            const currentOrder = validOrders[currentBatchIdx];
            if (currentOrder) {
              const rowIdx = csvOrders.indexOf(currentOrder);
              const statusEl = document.getElementById('csv-status-' + rowIdx);
              if (statusEl) {
                statusEl.textContent = 'RUN';
                statusEl.className = 'row-status running';
              }
            }
          }

          batchLabel.textContent = bp.orderId
            ? `${bp.orderId} - ${bp.product}`
            : `주문 ${bp.current}/${bp.total}`;
          saveState();
        }

        // 배치 완료
        if (status.step === 'batch_done' || status.step === 'batch_error') {
          eventSource.close();
          setBatchUIState('done');
          batchStatusMessage.style.color = status.step === 'batch_done' ? '#00ff88' : '#ff6b6b';
          if (status.batchProgress && status.batchProgress.results) {
            status.batchProgress.results.forEach((r, i) => updateCsvRowStatus(i, r, validOrders));
          }
        }

        // 배치 중지됨 → 이어하기 가능
        if (status.step === 'batch_stopped') {
          eventSource.close();
          setBatchUIState('stopped');
          batchStatusMessage.style.color = '#ff6b6b';
          if (status.batchProgress && status.batchProgress.results) {
            status.batchProgress.results.forEach((r, i) => updateCsvRowStatus(i, r, validOrders));
          }
        }
      };
    }

    // CSV 일괄주문 실행
    csvBatchBtn.addEventListener('click', async () => {
      if (!csvOrders) return;

      const validOrders = csvOrders.filter(o => o.valid);
      if (validOrders.length === 0) {
        alert('유효한 주문이 없습니다.');
        return;
      }

      if (!confirm(`${validOrders.length}건의 주문을 실행합니다. 계속하시겠습니까?`)) return;

      setBatchUIState('running');
      batchProgressCard.style.display = 'block';
      batchProgressBar.style.width = '0%';
      batchLabel.textContent = '배치 시작 중...';
      batchCount.textContent = `0/${validOrders.length}`;
      batchStatusMessage.textContent = '준비 중...';
      batchStatusMessage.style.color = '#8892b0';

      // 테이블 상태 초기화
      validOrders.forEach((o, i) => {
        const statusEl = document.getElementById('csv-status-' + csvOrders.indexOf(o));
        if (statusEl) {
          statusEl.textContent = 'WAIT';
          statusEl.className = 'row-status pending';
        }
      });

      connectBatchSSE();

      // 배치 실행 요청
      try {
        const response = await fetch('/api/order/batch', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ orders: validOrders })
        });
        const data = await response.json();
        if (!data.success && data.error) {
          alert('오류: ' + data.error);
          setBatchUIState('idle');
          batchProgressCard.style.display = 'none';
        }
      } catch (error) {
        alert('오류: ' + error.message);
        setBatchUIState('idle');
        batchProgressCard.style.display = 'none';
      }
    });

    // 중지/이어하기 토글 버튼
    csvStopBtn.addEventListener('click', async () => {
      csvStopBtn.disabled = true;

      if (stopBtnMode === 'stop') {
        // === 배치 중지 ===
        csvStopBtn.textContent = '중지 요청 중...';
        try {
          const response = await fetch('/api/batch/stop', { method: 'POST' });
          const data = await response.json();
          console.log('[UI] 배치 중지 응답:', data);
          // SSE는 batch_stopped 메시지 수신 시 자동으로 닫히고 UI 전환됨
          // 서버가 batch_stopped을 보내기 전에 SSE가 이미 닫힌 경우를 위한 폴백
          setTimeout(() => {
            if (batchRunning) {
              if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
                eventSource.close();
              }
              setBatchUIState('stopped');
              batchStatusMessage.textContent = '배치가 중지되었습니다.';
              batchStatusMessage.style.color = '#ff6b6b';
            }
          }, 5000);
        } catch (error) {
          console.error('[UI] 배치 중지 오류:', error);
          csvStopBtn.disabled = false;
          csvStopBtn.textContent = '배치 중지';
          alert('중지 요청 실패: ' + error.message);
        }
      } else {
        // === 이어하기 ===
        csvStopBtn.textContent = '이어하기 요청 중...';
        try {
          connectBatchSSE();
          const response = await fetch('/api/batch/resume', { method: 'POST' });
          const data = await response.json();
          console.log('[UI] 이어하기 응답:', data);
          if (data.success) {
            setBatchUIState('running');
            batchStatusMessage.textContent = `${data.remaining}건 이어하기 시작...`;
            batchStatusMessage.style.color = '#8892b0';
          } else {
            if (eventSource) eventSource.close();
            alert('이어하기 실패: ' + data.message);
            csvStopBtn.disabled = false;
            csvStopBtn.textContent = '이어하기';
          }
        } catch (error) {
          console.error('[UI] 이어하기 오류:', error);
          if (eventSource) eventSource.close();
          csvStopBtn.disabled = false;
          csvStopBtn.textContent = '이어하기';
          alert('이어하기 요청 실패: ' + error.message);
        }
      }
    });

    function updateCsvRowStatus(validIdx, result, ordersOverride) {
      if (!csvOrders) return;
      const validOrders = ordersOverride || csvOrders.filter(o => o.valid);
      const order = validOrders[validIdx];
      if (!order) return;
      const rowIdx = csvOrders.indexOf(order);
      const statusEl = document.getElementById('csv-status-' + rowIdx);
      if (!statusEl) return;

      const rowEl = document.getElementById('csv-row-' + rowIdx);
      if (result.success) {
        statusEl.textContent = 'OK';
        statusEl.className = 'row-status ok';
        statusEl.title = '';
        statusEl.style.cursor = '';
        if (rowEl) rowEl.classList.remove('execution-failed');
      } else {
        statusEl.textContent = 'FAIL';
        statusEl.className = 'row-status fail';
        statusEl.title = result.message || '알 수 없는 오류';
        statusEl.style.cursor = 'help';
        if (rowEl) rowEl.classList.add('execution-failed');
      }
      saveState();
    }

    // 단건 실행 (주문번호로 검색 후 1건 배치 실행)
    csvSingleBtn.addEventListener('click', async () => {
      const orderId = orderIdInput.value.trim();
      if (!orderId) {
        alert('주문번호를 입력해주세요.');
        return;
      }

      const order = csvOrders && csvOrders.find(o => o.orderId === orderId);
      if (!order) {
        alert(`주문번호 "${orderId}"를 찾을 수 없습니다.`);
        return;
      }
      if (!order.valid) {
        alert(`주문번호 "${orderId}"는 유효하지 않은 주문입니다.\n누락 항목: ${order.missing ? order.missing.join(', ') : '알 수 없음'}`);
        return;
      }
      if (!browserConnected) {
        alert('브라우저가 연결되지 않았습니다.');
        return;
      }

      if (!confirm(`주문번호 "${orderId}" 단건 실행합니다. 계속하시겠습니까?`)) return;

      setBatchUIState('running');
      batchProgressCard.style.display = 'block';
      batchProgressBar.style.width = '0%';
      batchLabel.textContent = `${orderId} - 단건 실행`;
      batchCount.textContent = '0/1';
      batchStatusMessage.textContent = '준비 중...';
      batchStatusMessage.style.color = '#8892b0';

      // 해당 행 상태 초기화
      const rowIdx = csvOrders.indexOf(order);
      const statusEl = document.getElementById('csv-status-' + rowIdx);
      if (statusEl) {
        statusEl.textContent = 'WAIT';
        statusEl.className = 'row-status pending';
      }

      connectBatchSSE([order]);

      try {
        const response = await fetch('/api/order/batch', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ orders: [order] })
        });
        const data = await response.json();
        if (!data.success && data.error) {
          if (eventSource) eventSource.close();
          alert('오류: ' + data.error);
          setBatchUIState('done');
        }
      } catch (error) {
        if (eventSource) eventSource.close();
        alert('오류: ' + error.message);
        setBatchUIState('done');
      }
    });

    // CSV 초기화
    csvClearBtn.addEventListener('click', async () => {
      try {
        await fetch('/api/batch/stop', { method: 'POST' });
      } catch (e) { /* ignore */ }
      if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
        eventSource.close();
      }
      csvBase64 = null;
      csvOrders = null;
      csvFileInput.value = '';
      csvFileName.textContent = '';
      csvPreviewCard.style.display = 'none';
      batchProgressCard.style.display = 'none';
      singleOrderArea.style.display = 'none';
      orderIdInput.value = '';
      setBatchUIState('idle');
      csvParseBtn.disabled = false;
      csvBatchBtn.disabled = true;
      clearSavedState();
    });

    // ===== 페이지 로드 시 상태 복원 =====
    loadState();
  </script>
</body>
</html>
